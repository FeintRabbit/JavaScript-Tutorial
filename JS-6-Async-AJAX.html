<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div>
      <h1>Asynchronous JavaScript</h1>
      <p>JS is synchronous & single threaded. Code is executed line by line</p>
      <p>Browser offers asynchronous functions, which takes a call back, performs the action then runs the callback when possible.</p>
    </div>
    <!-- ------------ -->
    <!-- Sync v Async -->
    <!-- ------------ -->
    <script>
      // syncronous behaviour
      console.log("boil water.. (10 sec)");
      // JS stop here for 10 sec, cannot execute the below
      console.log("water boiled");
      console.log("chop carrots");

      // asyncronous behaviour
      boilWater(100);
      // JS does not stop, it hands the 'boil' task to browser, and continues on to chop carrots, then gets the 'done' callback when browser is ready.
      console.log("chop carrots");

      function boilWater(time) {
        console.log("boiling...");
        setTimeout(() => {
          console.log("done");
        }, time);
      }
    </script>
    <!-- --------------- -->
    <!-- Callback (hell) -->
    <!-- --------------- -->
    <div>
      <h1>Callback (hell)</h1>
      <p>nesting callbacks to sequence behaviour</p>

      <button class="btn">Click me bby</button>
      <h2 class="one">Hello world</h2>
      <h2 class="two">Hello people</h2>
      <h2 class="three">Hello JavaScript</h2>
    </div>
    <script>
      const heading1 = document.querySelector(".one");
      const heading2 = document.querySelector(".two");
      const heading3 = document.querySelector(".three");
      const btn = document.querySelector(".btn");

      // using nested callbacks, we can pass a function (new async) when the async callback is run
      btn.addEventListener("click", () => {
        setTimeout(() => {
          heading1.style.color = "red";
          setTimeout(() => {
            heading2.style.color = "green";
            setTimeout(() => {
              heading3.style.color = "blue";
            }, 1000);
          }, 2000);
        }, 1000);
      });
    </script>
    <!-- ------- -->
    <!-- Promise -->
    <!-- ------- -->
    <div>
      <h1>Promise</h1>
      <p>Pending, resolves, rejected</p>
      <p>When promise is called, it's pending. Only fires callback when a value comes back (resolve or rejected), .then() handles the promise return.</p>
      <button class="btn2">Click me img</button>
      <button class="btn3">Click me promise</button>
      <div class="container"></div>
    </div>
    <script>
      // **** true/false example ****

      // declare a promise
      // takes parameters resolve, reject (any name)
      // promise happens right away, then fullfills callback
      const promise = new Promise((resolve, reject) => {
        let value = true;
        if (value) {
          resolve("pass: hey value is true");
        } else {
          reject(`fail: there was an error, value is false`);
        }
      });
      console.log(promise.value); // undefined :(

      // to access the data on success, use .then()
      promise
        .then(result => {
          console.log(result);
        }) // catch for error
        .catch(err => {
          console.log(err);
        });

      // **** image load (handle error) example ****
      const container = document.querySelector(".container");
      const btn2 = document.querySelector(".btn2");
      const imgUrl = "https://source.unsplash.com/random";

      btn2.addEventListener("click", () => {
        loadImage(imgUrl)
          .then(taco => container.appendChild(taco))
          .catch(err => console.log(err));
      });

      // this function returns a promise, which is accessed above
      function loadImage(imgUrl) {
        return new Promise((resolve, reject) => {
          let img = new Image();
          img.addEventListener("load", () => {
            resolve(img);
          });
          img.addEventListener("error", () => {
            reject(new Error("Fail to load image"));
          });
          img.src = imgUrl;
        });
      }
      // long hand syntax:
      // function loadImage(url) {
      //   const promise = new Promise((resolve, reject) => {
      //     return promise;
      //   });
      // }

      // **** DOM example ****
      const btn3 = document.querySelector(".btn3");

      btn3.addEventListener("click", () => {
        addColor(1000, heading1, "red")
          .then(() => addColor(2000, heading2, "green")) // NOTE IMPLICIT RETURNS!!!!
          .then(() => addColor(1000, heading3, "blue"))
          .catch(err => console.log(err));
      });
      // Explicit return example:
      // btn3.addEventListener("click", () => {
      //   addColor(1000, heading1, "red").then(() => {
      //     return addColor(2000, heading2, "green").then(() => {
      //       return addColor(1000, heading3, "blue");
      //     });
      //   });
      // });

      function addColor(time, element, color) {
        return new Promise((resolve, reject) => {
          if (element) {
            setTimeout(() => {
              element.style.color = color;
              resolve();
            }, time);
          } else {
            reject(new Error(`no such element: ${element}`));
          }
        });
      }
    </script>
    <!-- ------------- -->
    <!-- Async / Await -->
    <!-- ------------- -->
    <div>
      <h1>Async / Await</h1>
      <p>Add async & await keywords to functions</p>
      <p>async function, awaits until the promise is resolved / rejected before moving to next line of code</p>
      <p>Adds syntactic sugar to the function calling the promise (removes .then()). Still using and returning a promise</p>
      <button class="btn4">Click me async/await</button>
    </div>
    <script>
      // async must be called per function:

      // normal function
      async function someFunction() {
        await "";
      }
      // arrow function
      const otherFunction = async () => {
        await "";
      };

      // **** DOM example ****
      const btn4 = document.querySelector(".btn4");

      btn4.addEventListener("click", async () => {
        await addColor2(1000, heading1, "red");
        await addColor2(1000, heading2, "green");
        await addColor2(1000, heading3, "blue");
      });

      // to catch an error, use a try block, with catch
      btn4.addEventListener("click", async () => {
        try {
          await addColor2(1000, heading1, "red");
          await addColor2(1000, heading2, "green");
          await addColor2(1000, heading3, "blue");
        } catch (error) {
          console.log(error);
        }
      });

      function addColor2(time, element, color) {
        return new Promise((resolve, reject) => {
          if (element) {
            setTimeout(() => {
              element.style.color = color;
              resolve();
            }, time);
          } else {
            reject(new Error(`no such element: ${element}`));
          }
        });
      }
    </script>
    <!-- ---- -->
    <!-- AJAX -->
    <!-- ---- -->
    <div>
      <h1>AJAX</h1>
      <p>Asynchronous JavaScript and XML</p>
      <button class="ajax-btn">AJAX</button>
      <p class="ajax-txt"></p>
    </div>
    <script>
      const ajaxBtn = document.querySelector(".ajax-btn");
      ajaxBtn.addEventListener("click", getData);

      function getData() {
        // create a new XHR object
        const xhr = new XMLHttpRequest();

        // set-up the request
        xhr.open("GET", "./api/sample.txt");

        // handle the logic for request fullfillment
        xhr.onreadystatechange = function () {
          // Success = wait for 'done (4)' & status = 200
          if (xhr.readyState === 4 && xhr.status === 200) {
            document.querySelector(".ajax-txt").textContent = xhr.responseText;
          }
          // otherwise, an issue occured
          else {
            console.log({
              status: xhr.status,
              text: xhr.statusText,
            });
          }
        };

        // fire the request (progress state change to 3 & 4)
        xhr.send();
      }
    </script>
    <!-- ---- -->
    <!-- JSON -->
    <!-- ---- -->
    <div>
      <h1>JSON</h1>
      <button class="json-btn">show json</button>
      <div class="json-txt"></div>
    </div>
    <script>
      const jsonBtn = document.querySelector(".json-btn");
      const url = "./api/people.json";
      jsonBtn.addEventListener("click", () => {
        getJSON(url);
      });

      function getJSON(url) {
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url);

        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4 && xhr.status === 200) {
            // initially comes back as string
            console.log(typeof xhr.responseText);
            // parse as JSON & insert to html
            const data = JSON.parse(xhr.responseText); // parse to JSON object
            const displayData = data.map(item => `<p>${item.name}</p>`).join(""); // create html
            document.querySelector(".json-txt").innerHTML = displayData; // insert html
          } else {
            console.log({
              status: xhr.status,
              text: xhr.statusText,
            });
          }
        };
        xhr.send();
      }
    </script>
  </body>
</html>
