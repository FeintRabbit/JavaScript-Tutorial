<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div>
      <h1>Asynchronous JavaScript</h1>
      <p>JS is synchronous & single threaded. Code is executed line by line</p>
      <p>Browser offers asynchronous functions, which takes a call back, performs the action then runs the callback when possible.</p>
    </div>
    <!-- ------------ -->
    <!-- Sync v Async -->
    <!-- ------------ -->
    <script>
      // syncronous behaviour
      console.log("boil water.. (10 sec)");
      // JS stop here for 10 sec, cannot execute the below
      console.log("water boiled");
      console.log("chop carrots");

      // asyncronous behaviour
      boilWater(100);
      // JS does not stop, it hands the 'boil' task to browser, and continues on to chop carrots, then gets the 'done' callback when browser is ready.
      console.log("chop carrots");

      function boilWater(time) {
        console.log("boiling...");
        setTimeout(() => {
          console.log("done");
        }, time);
      }
    </script>
    <!-- --------------- -->
    <!-- Callback (hell) -->
    <!-- --------------- -->
    <div>
      <h1>Callback (hell)</h1>
      <p>nesting callbacks to sequence behaviour</p>

      <button class="btn">Click me bby</button>
      <h2 class="one">Hello world</h2>
      <h2 class="two">Hello people</h2>
      <h2 class="three">Hello JavaScript</h2>
    </div>
    <script>
      const heading1 = document.querySelector(".one");
      const heading2 = document.querySelector(".two");
      const heading3 = document.querySelector(".three");
      const btn = document.querySelector(".btn");

      // using nested callbacks, we can pass a function (new async) when the async callback is run
      btn.addEventListener("click", () => {
        setTimeout(() => {
          heading1.style.color = "red";
          setTimeout(() => {
            heading2.style.color = "green";
            setTimeout(() => {
              heading3.style.color = "blue";
            }, 1000);
          }, 2000);
        }, 1000);
      });
    </script>
    <!-- ------- -->
    <!-- Promise -->
    <!-- ------- -->
    <div>
      <h1>Promise</h1>
      <p>Pending, resolves, rejected</p>
      <div class="container"></div>
    </div>
    <script>
      // declare a promise
      // takes parameters resolve, reject (any name)
      // promise happens right away, then fullfills callback
      const promise = new Promise((resolve, reject) => {
        let value = true;
        if (value) {
          resolve("pass: hey value is true");
        } else {
          reject(`fail: there was an error, value is false`);
        }
      });
      console.log(promise.value); // undefined :(

      // to access the data on success, use .then()
      promise
        .then(result => {
          console.log(result);
        }) // catch for error
        .catch(err => {
          console.log(err);
        });

      // **** image load example ****
      const container = document.querySelector(".container");
      const url = "https://source.unsplash.com/random";
      btn.addEventListener("click", () => {
        loadImage(url)
          .then(taco => container.appendChild(taco))
          .catch(err => console.log(err));
      });

      function loadImage(url) {
        return new Promise((resolve, reject) => {
          let img = new Image();
          img.addEventListener("load", () => {
            resolve(img);
          });
          img.addEventListener("error", () => {
            reject(new Error("Fail to load image"));
          });
          img.src = url;
        });
      }
      // long hand syntax:
      // function loadImage(url) {
      //   const promise = new Promise((resolve, reject) => {
      //     return promise;
      //   });
      // }
    </script>
  </body>
</html>
